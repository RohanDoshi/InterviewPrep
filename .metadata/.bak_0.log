!SESSION 2014-09-22 08:51:19.815 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

This is a continuation of log file /Users/rdoshi61/Documents/workspace/.metadata/.bak_0.log
Created Time: 2014-10-20 06:23:23.214

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.215
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.222
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.223
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.223
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.238
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.238
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.239
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.246
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.247
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.247
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.255
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.256
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.257
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.264
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.264
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.265
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.272
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.272
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.273
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.281
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.281
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.282
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.290
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.291
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.291
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.299
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.300
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.300
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.308
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.309
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.309
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.317
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.317
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.318
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.325
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.326
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.326
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.333
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.342
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.342
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.350
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.350
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.350
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.359
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.360
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.360
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.368
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.369
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.369
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.377
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.377
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.385
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.385
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.385
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.393
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.394
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.394
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.403
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.403
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.403
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.411
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.412
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.412
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.422
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.422
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.422
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.429
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.430
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.430
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.437
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.438
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.438
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.446
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.447
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.447
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.455
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.456
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.456
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.472
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.472
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.479
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.480
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.480
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.488
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.488
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.496
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.496
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.496
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.504
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.505
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.505
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.512
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.513
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.513
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.520
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.520
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.520
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.528
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.528
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.529
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.538
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.538
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.539
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.546
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.546
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.546
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.554
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.554
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.555
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.562
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.563
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.563
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.571
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.571
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.571
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.579
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.579
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.579
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:23:23.594
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn(char[] pre, char)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:23:23.594
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:23:23.595
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:10.121
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(i)
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:10.122
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:10.123
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:13.139
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:13.139
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:13.140
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:13.223
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:13.224
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:13.224
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:17.695
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] a. )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:17.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:17.696
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:17.706
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] a. )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:17.707
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:17.707
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:21.214
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] arr, )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:21.215
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:21.215
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:21.224
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] arr, )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:21.224
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:21.224
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-10-20 06:33:21.384
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pack;

import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class BTStanford {

	public static void main(String args[]) throws CloneNotSupportedException {
//		int parent[] = {2,12,-4,3,9,21,19,25};
//		BinaryTree binaryTree = new BinaryTree(5);
//		for(int i=0; i<parent.length; i++) {
//			binaryTree.insert(parent[i]);
//		}
////		binaryTree.inOrderIteration();
////		System.out.println();
////		binaryTree.preOrderIteration();
////		System.out.println();
////		binaryTree.postOrderIteration();
////		binaryTree.lowestCommonAncestor(19, 25);
//		System.out.println(binaryTree.diameter());
		BinaryTree binaryTree = new BinaryTree();
		System.out.println(binaryTree.isSubtree());
		
	}
}


class BinaryTree implements Cloneable{
	private Node root;
	private Node n1 = null;
	private Node n2 = null;
	
	private char[] pre = {'A', 'B', 'D', 'E', 'C', 'F'};
	private char[] in = {'D', 'B' ,'E' ,'A' ,'F', 'C'} ;
	
	public Node constructTreePreIn() {
		return constructTreePreIn(pre,in);
	}
	
	public Node constructTreePreIn(char[] pre, char[] in) {
		for(int i=0; i<pre.length; i++) {
			
		}
	}
	
	private int findIndex(char[] arr, )
	 class Node {
		Node left; 
		Node right;
		int data;
		char c;
		public Node(int data) {
			this.data = data;
		}
		
		public Node(char c) {
			this.c = c;
		}
		
		@Override
		public String toString() {
			return Integer.toString(data);
		}
	}
	 
	 public BinaryTree() {
		n2 = new Node(10);
		n2.left = new Node(4);
		n2.right = new Node(61);
		n2.left.right = new Node(30);
		
		n1 = new Node(26);
		n1.left = new Node(10);
		n1.right = new Node(3);
		n1.left.left = new Node(4);
		n1.left.right = new Node(6);
		n1.left.left.right = new Node(30);
		n1.right.right = new Node(3);
	}
	 
	public boolean isSubtree() {
		return isSubtree(n1, n2, false) ;
	}
	
	public boolean isSubtree(Node node1, Node node2, boolean matchFound) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node2 == null) {
			return true;
		}
		
		if(node1 == null) {
			return false;
		}
		
		if(node1.data == node2.data) {
			boolean left = isSubtree(node1.left, node2.left, true) ;
			boolean right = isSubtree(node1.right, node2.right, true);
			return left && right;
		} else { 
			if(matchFound == true) {
				return false;
			}
			boolean left = isSubtree(node1.left, node2, false);
			boolean right = isSubtree(node1.right, node2, false);
			return left || right;
		}
		
		
	}
	 
	public int diameter() { 
		return diameter(root);
	}
	
	public int diameter(Node node) { 
		if(node == null) {
			return 0;
		}
		
		int diaViaRoot = 1 + height(node.left) + height(node.right);
		int diaInLeft = diameter(node.left);
		int diaInRight = diameter(node.right);
		
		return Math.max(diaViaRoot, Math.max(diaInLeft, diaInRight));
		
	}
	
	public int height(Node node) {
		if(node == null) {
			return 0;
		}
		
		return 1 + Math.max(height(node.left), height(node.right));
	}
	 
	public boolean isBST2() {
		return isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}
	 
	public boolean isBST2(Node node, int min, int max) {
		if(node == null)
			return true;
		
		boolean left = isBST2(node.left, min, node.data);
		boolean right = isBST2(node.right, node.data, max);
		if(node.data < min || node.data > max) {
			return false;
		} else
			return left && right;
	}
	public boolean isBST() {
		return isBST(root);
	}
	
	public boolean isBST(Node node) {
		if(node == null) {
			return true;
		}
		
		boolean left = isBST(node.left);
		boolean right = isBST(node.right);
		
		if(node.left != null && node.data < maxValue(node.left)) {
			return false;
		} else if(node.right != null && node.data > minValue(node.right)) {
			return false;
		} else {
			return left && right;
		}
	}
	 
	public int maxValue(Node node) {
		if(node == null) {
				throw new NullPointerException(); 
		}
		
		if(node.right == null) {
			return node.data;
		} else {
			return maxValue(node.right);
		}
		
	}
	
	 
	public int countPossibleBST(int numNodes) {
	
		if(numNodes <= 1) {
			return 1;
		}
		
		int count = 0;
		for(int i=1; i<=numNodes; i++) {
			count += countPossibleBST(i-1) * countPossibleBST(numNodes-i);
		}
		
		return count;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	public Node getRoot() {
		return this.root;
	}
	
	public boolean isSameTree(BinaryTree binaryTree) { 
		return isSameTree(this.root, binaryTree.getRoot());
	}
	
	private boolean isSameTree(Node node1, Node node2) {
		if(node1 == null && node2 == null) {
			return true;
		}
		if(node1 == null || node2 == null) {
			return false;
		}
		if(node1.data == node2.data) {
			boolean left = isSameTree(node1.left, node2.left);
			boolean right = false;
			if(left) {
				right = isSameTree(node1.right, node2.right);
			}
			return left && right;
		} else
			return false;
	}
	
	
	public void doubleTree() { 
		root = doubleTree(root);
	}
	
	public Node doubleTree(Node node) {
		if(node == null) {
			return node; 
		}
		
		Node newNode = new Node(node.data);
		Node left = node.left;
		node.left = newNode;
		newNode.left = doubleTree(left);
		node.right = doubleTree(node.right);
		return node;
		
	}
	
	public void mirror() { 
		root = mirror(root);
	}
	
	public Node mirror(Node node) {
		if(node == null) {
			return node;
		}
		
		node.left = mirror(node.left);
		node.right = mirror(node.right);
		
		Node temp = node.left; 
		node.left = node.right;
		node.right = temp;
		return node;
	}
	
	public void printPaths() {
		//printPaths(root, new ArrayList<Node>());1
		printPaths2(root, new Node[1000], 0);
	}
	
	public void printPaths2(Node node, Node[] list, int len) {
		if(node == null) {
			return;
		}
		list[len++] = node;
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list));
			list[--len] = null;
			return;
		}
		
		printPaths2(node.left, list, len);
		printPaths2(node.right, list, len);
	}
	
	public void printPaths(Node node, List<Node> list) {
		if(node == null) {
			return;
		}
		list.add(node);
		if(node.left == null && node.right == null) {
			System.out.println(Arrays.toString(list.toArray()));
			list.remove(node);
			return;
		} 
		
		printPaths(node.left, list);
		printPaths(node.right, list);
		list.remove(node);
	}
	
	public boolean hasPathSum(int sum) {
		return hasPathSum(root, 0, sum);
	}
	
	private boolean hasPathSum(Node node, int currSum, int sum) {
		if(node == null) {
			if(sum == currSum) {
				return true;
			} else {
				return false;
			}
		}
		
		boolean left = hasPathSum(node.left, currSum + node.data, sum);
		boolean right = hasPathSum(node.right, currSum + node.data, sum);
		return left || right;
	}
	
	public void postOrder() {
		postOrder(root);
		System.out.println();
	}
	public void postOrder(Node node) {
		if(node != null) {
			postOrder(node.left);
			postOrder(node.right);
			System.out.print(node.data+ " ");
		}
	}
	
	public void preOrder() {
		preOrder(root);
		System.out.println();
	}
	public void preOrder(Node node) {
		if(node != null) {
			System.out.print(node.data+" ");
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	public int maxDepth() {
		return maxDepth(root);
	}
	public int maxDepth(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
		}
	}
	public int size() {
		return size(root);
	}
	public BinaryTree(int rootData){
		root = new Node(rootData);
	}
	
	public int size(Node node) {
		if(node == null) {
			return 0;
		} else {
			return 1 + size(node.left) + size(node.right);
		}
	}
	
	public void insert(int data) {
		insert(root,data);
	}
	
	public Node insert(Node node, int data) {
		if(node == null) {
			node = new Node(data);
		} else if(data <= node.data) {
			node.left = insert(node.left, data);
		} else {
			node.right = insert(node.right, data) ;
		}
		return node;
	}
	
	public Node delete(int data) {
		root =  delete(root, data);
		return root;
	}
	
	public Node delete(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			if(node.left == null && node.right == null) {
				node = null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else { 
				int minVal = minValue(node.right);
				node.right = delete(node.right, minVal);
				node.data = minVal;
			}
		} else if(data < node.data) {
			node.left = delete(node.left, data);
		} else {
			node.right = delete(node.right, data);
		}
		return node; 
	}
	
	public int minValue(Node node) {
		if(node == null) {
			throw new NullPointerException();
		} else if(node.left == null) {
			return node.data;
		} else {
			return minValue(node.left);
		}
	}
	
	public Node minNode(Node node) {
		if(node == null || node.left == null) {
			return node;
		} else {
			return minNode(node.left);
		}
	}
	
	public Node lookup(int data) {
		return lookup(root, data);
	}
	
	public Node lookup(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(data == node.data) {
			return node; 
		} else if(data < root.data) {
			return lookup(root.left, data);
		} else {
			return lookup(root.right, data);
		}
	}
	
	public void inOrder() {
		inOrder(root);
		System.out.println();
	}
	
	public void inOrderIteration() {
		
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		boolean done = false;
		while(!done) {
			if(currNode != null) {
				stack.push(currNode);
				currNode = currNode.left;
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				currNode = currNode.right;
			}
			if(stack.size() == 0 && currNode == null)
				done = true;
		}
	}
	
	public void preOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root;
		stack.push(currNode);
		while(stack.size() > 0) {
			currNode = stack.pop();
			System.out.print(currNode.data+" ");
			if(currNode.right != null) {
				stack.push(currNode.right);
			}  
			if(currNode.left != null) {
				stack.push(currNode.left);
			}
			
		}
	}
	
	public void postOrderIteration() {
		Stack<Node> stack = new Stack<>();
		Node currNode = root, prevNode = null;
		stack.push(currNode);
		while(stack.size() >0 ) {
			currNode = stack.peek();
			if(prevNode == null || (currNode.left != prevNode && currNode.right != prevNode)) {
				if(currNode.right != null) {
					stack.push(currNode.right);
					if(currNode.left != null) {
						stack.push(currNode.left);
					}
				}
				else if(currNode.left != null) {
					stack.push(currNode.left);
				} else { 
					currNode = stack.pop();
					System.out.print(currNode.data+" ");
					prevNode = currNode;
				}
			} else {
				currNode = stack.pop();
				System.out.print(currNode.data+" ");
				prevNode = currNode;
			}
 		}
	}
	
	public void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.print(root.data+" ");
			inOrder(root.right);
		}
	}
	
	public void deleteTry(int data) {
		deleteTry(root, data);
	}
	
	public Node deleteTry(Node node, int data) {
		if(node == null) {
			return node;
		}
		if(node.data == data) {
			if(node.left == null && node.right == null) {
				return null;
			} else if(node.left == null) {
				node = node.right;
			} else if(node.right == null) {
				node = node.left;
			} else {
				Node minNode = minNode(node.right);
				node.data = minNode.data;
				node.right = deleteTry(node.right, minNode.data);
			}
			
		} else if(data < node.data){ 
			node.left = deleteTry(node.left, data);
		} else { 
			node.right = deleteTry(node.right, data);
		}
		return node;
	}
	
	public void lowestCommonAncestor(int a, int b) {
		Node node = lca(root, a, b);
		System.out.println(node.data);
	}
	
	public Node lca(Node node, int a, int b) {
		if(node == null) {
			return null;
		}
	
		Node left = lca(node.left, a, b);
		Node right = lca(node.right, a, b);
		if(left != null && right != null) {
			return node;
		} else if((node.data == a || node.data == b) && (left!=null || right!=null)) {
			return node;
		} else if(node.data == a || node.data == b) {
			return node;
		} else {
			return (left != null) ? left : right;
		}
	}
	
	public boolean isNodeExists(int a) {
		return isNodeExists(root, a);
	}
	
	public boolean isNodeExists(Node node, int a) {
		if(node == null) {
			return false;
		}
		
		if(node.data == a) {
			return true;
		} else {
			boolean left = false, right = false;
			 left = isNodeExists(node.left, a);
			 if(!left)
			 right = isNodeExists(node.right, a);
			 return left || right;
		}
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-10-20 06:33:21.384
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-10-20 06:33:21.385
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:437)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2449)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:537)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:186)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2679)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.ui 4 4 2014-10-21 05:42:43.870
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-21 05:42:43.871
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-21 05:42:43.872
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-21 05:42:43.872
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-21 05:42:43.873
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-21 05:42:43.873
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies
!SESSION 2014-10-21 14:45:40.083 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.resources 2 10035 2014-10-21 14:50:47.406
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 4 4 2014-10-22 13:39:56.809
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-22 13:39:56.817
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-22 13:39:56.818
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-22 13:39:56.818
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-22 13:39:56.822
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-22 13:39:56.822
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-24 14:49:09.662
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-24 14:49:09.663
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-24 14:49:09.663
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-24 14:49:09.663
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-24 14:49:09.670
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-24 14:49:09.670
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies
!SESSION 2014-10-24 20:04:47.373 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2014-10-24 20:04:53.450
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2014-10-25 16:35:15.164 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.resources 2 10035 2014-10-25 16:35:42.245
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 4 4 2014-10-26 14:34:17.578
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-26 14:34:17.585
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-26 14:34:17.585
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-26 14:34:17.586
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.ui 4 4 2014-10-26 14:34:17.587
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.disable.grammar.constraints

!ENTRY org.eclipse.ui 4 4 2014-10-26 14:34:17.587
!MESSAGE Could not retrieve EHandlerService or ICommandService from context evaluation context fororg.eclipse.wst.xml.ui.reload.dependencies

!ENTRY org.eclipse.jdt.core 4 4 2014-10-27 02:31:37.565
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException: A resource exists with a different case: '/JavaProject/bin/Int1.class'.
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:329)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:307)
	at org.eclipse.core.internal.resources.File.create(File.java:111)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:858)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:189)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:510)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:270)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:193)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:733)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2014-10-27 02:31:37.567
!MESSAGE A resource exists with a different case: '/JavaProject/bin/Int1.class'.

!ENTRY org.eclipse.jdt.core 4 4 2014-10-27 02:32:00.951
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException: A resource exists with a different case: '/JavaProject/bin/Int2.class'.
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:329)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:307)
	at org.eclipse.core.internal.resources.File.create(File.java:111)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:858)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:189)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:510)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:270)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:193)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:733)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2014-10-27 02:32:00.951
!MESSAGE A resource exists with a different case: '/JavaProject/bin/Int2.class'.

!ENTRY org.eclipse.jdt.core 4 4 2014-10-27 02:32:00.952
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException: A resource exists with a different case: '/JavaProject/bin/Int1.class'.
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:329)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:307)
	at org.eclipse.core.internal.resources.File.create(File.java:111)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:858)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:189)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:510)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:270)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:193)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:733)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2014-10-27 02:32:00.952
!MESSAGE A resource exists with a different case: '/JavaProject/bin/Int1.class'.
!SESSION 2014-12-08 09:02:10.431 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2014-12-08 09:02:23.237
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2014-12-22 15:37:39.706 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.jdt.core 4 4 2014-12-22 15:38:42.170
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException: A resource exists with a different case: '/JavaProject/bin/Int2.class'.
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:329)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:307)
	at org.eclipse.core.internal.resources.File.create(File.java:111)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:858)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:189)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:510)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:173)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:733)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2014-12-22 15:38:42.171
!MESSAGE A resource exists with a different case: '/JavaProject/bin/Int2.class'.

!ENTRY org.eclipse.jdt.core 4 4 2014-12-22 15:38:42.175
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException: A resource exists with a different case: '/JavaProject/bin/Int1.class'.
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:329)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:307)
	at org.eclipse.core.internal.resources.File.create(File.java:111)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:858)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:189)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:510)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:173)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:733)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2014-12-22 15:38:42.176
!MESSAGE A resource exists with a different case: '/JavaProject/bin/Int1.class'.
!SESSION 2015-01-21 11:48:51.294 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-01-21 11:49:05.999
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-01-29 11:00:54.396 -----------------------------------------------
eclipse.buildId=4.3.2.M20140221-1700
java.version=1.7.0_51
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -keyring /Users/rdoshi61/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-01-29 11:01:05.336
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.cdt.core 1 0 2015-01-29 11:03:18.109
!MESSAGE Indexed 'Debug_point_search.exe' (0 sources, 0 headers) in 0.00 sec: 0 declarations; 0 references; 0 unresolved inclusions; 0 syntax errors; 0 unresolved names (0.00%)

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.801
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.actions.refresh.all

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.801
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.actions.refresh.sourcefolders

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.801
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.actions.refresh.dependencies

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.801
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.ui.actions.DisableGradleNatureAction

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.801
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.ui.EnableDisableDependencyManagementActionDelegate

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.802
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.ui.actions.EnableDisableDSLSupportDelegate

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:03:59.802
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.ui.actions.Console

!ENTRY org.eclipse.cdt.core 1 0 2015-01-29 11:04:53.074
!MESSAGE Indexed 'challenge' (0 sources, 1 headers) in 0.18 sec: 21 declarations; 11 references; 1 unresolved inclusions; 0 syntax errors; 4 unresolved names (11.11%)

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:05:08.428
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.actions.refresh.all

!ENTRY org.eclipse.ui 4 4 2015-01-29 11:05:08.428
!MESSAGE Plug-in 'org.springsource.ide.eclipse.gradle.ui' contributed an invalid Menu Extension (Path: 'org.springsource.ide.eclipse.gradle.menu' is invalid): org.springsource.ide.eclipse.gradle.actions.refresh.sourcefolders
